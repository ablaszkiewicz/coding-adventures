(function(){"use strict";class D{constructor(t,s){this.min=t,this.max=s}surrounds(t){return t>=this.min&&t<=this.max}clamp(t){return t<this.min?this.min:t>this.max?this.max:t}}function I(r,t,s){const{data:e}=r,{x:i,y:n}=t,{x:o,y:l,z:h}=s,c=(n*r.width+i)*4,d=new D(0,.999),u=256*d.clamp(o),f=256*d.clamp(l),v=256*d.clamp(h);e[c]=u,e[c+1]=f,e[c+2]=v,e[c+3]=255}class x{constructor(t,s){this.origin=t,this.direction=s}at(t){return this.origin.add(this.direction.scalarMultiply(t))}}const y=Number.POSITIVE_INFINITY;function M(r,t){return Math.random()*(t-r)+r}const q=r=>new a(r.z,r.y,-r.x);class a{constructor(t,s,e){this.x=t,this.y=s,this.z=e}add(t){return new a(this.x+t.x,this.y+t.y,this.z+t.z)}subtract(t){return new a(this.x-t.x,this.y-t.y,this.z-t.z)}scalarMultiply(t){return new a(this.x*t,this.y*t,this.z*t)}multiply(t){return new a(this.x*t.x,this.y*t.y,this.z*t.z)}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return new a(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}unit(){return this.scalarMultiply(1/this.length())}randomOnHemisphere(){const t=a.randomInUnitSphere();return t.dot(this)>0?t:t.scalarMultiply(-1)}nearZero(){return Math.abs(this.x)<1e-8&&Math.abs(this.y)<1e-8&&Math.abs(this.z)<1e-8}reflect(t){return this.subtract(t.scalarMultiply(2*this.dot(t)))}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}static randomInUnitSphere(){for(;;){const t=a.randomBetween(-1,1);if(!(t.lengthSquared()>=1))return t}}static randomUnitVector(){return a.randomInUnitSphere().unit()}static random(){return new a((Math.random()-.5)*y,(Math.random()-.5)*y,(Math.random()-.5)*y)}static randomBetween(t,s){return new a(M(t,s),M(t,s),M(t,s))}}var w=(r=>(r.Lambertian="Lambertian",r.Metal="Metal",r))(w||{});class g{scatter(t,s){return{didScatter:!1}}}class z extends g{constructor(t){super(),this.albedo=t}scatter(t,s){let e=s.normal.add(a.randomUnitVector());e.nearZero()&&(e=s.normal);const i=new x(s.position,e),n=this.albedo;return{didScatter:!0,scattered:i,attentuation:n}}}class S{position=new a(0,0,0);normal=new a(0,0,0);t=0;material=new z(new a(0,0,0));constructor(){}setFaceNormal(t,s){t.direction.dot(s)<0?this.normal=s:this.normal=s.scalarMultiply(-1)}}const m=800,U=16/9,p=m/U;class T{center;pixel00Position;pixelDeltaU;pixelDeltaV;pixelSamplesScale;render(t,s,e){this.initialize(s);const i=new ImageData(m,p);let n=0;for(let o=0;o<m;o++)for(let l=0;l<p;l++){let h=new a(0,0,0);for(let d=0;d<s.samples;d++){const u=this.getRay(o,l);h=h.add(this.rayColor(u,t,s.bounces))}I(i,{x:o,y:l},h.scalarMultiply(this.pixelSamplesScale));const c=(o*p+l)/(m*p)*100;e&&c-n>1&&(e(c),n=c)}return i}initialize(t){this.center=new a(0,.5,.5),this.pixelSamplesScale=1/t.samples;const s=1,e=2,i=e*m/p,n=new a(i,0,0),o=new a(0,-e,0);this.pixelDeltaU=n.scalarMultiply(1/m),this.pixelDeltaV=o.scalarMultiply(1/p),this.pixel00Position=this.center.subtract(new a(0,0,s)).subtract(n.scalarMultiply(.5)).subtract(o.scalarMultiply(.5))}rayColor(t,s,e){if(e<=0)return new a(0,0,0);const i=new S;if(s.hit(t,.001,y,i)){const l=i.material.scatter(t,i);return l.didScatter?this.rayColor(l.scattered,s,e-1).multiply(l.attentuation):new a(0,0,0)}const o=.5*(t.direction.unit().y+1);return new a(.5,.7,1).scalarMultiply(o).add(new a(1,1,1).scalarMultiply(1-o))}getRay(t,s){const e=this.sampleSquare(),i=this.pixel00Position.add(this.pixelDeltaU.scalarMultiply(t+e.x)).add(this.pixelDeltaV.scalarMultiply(s+e.y)),n=this.center,o=i.subtract(this.center);return new x(n,o)}sampleSquare(){return new a(Math.random()-.5,Math.random()-.5,0)}}class H{constructor(t){this.objects=t}hit(t,s,e,i){const n=new S;let o=!1,l=e;for(const h of this.objects)h.hit(t,s,l,n)&&(o=!0,l=n.t,i.normal=n.normal,i.position=n.position,i.t=n.t,i.material=n.material);return o}}class L extends g{constructor(t){super(),this.albedo=t}scatter(t,s){const e=t.direction.reflect(s.normal),i=new x(s.position,e),n=this.albedo;return{didScatter:!0,scattered:i,attentuation:n}}}class b{constructor(t,s,e,i){switch(this.center=t,this.radius=s,this.materialType=e,this.color=i,e){case w.Metal:this.material=new L(i);break;case w.Lambertian:this.material=new z(i);break;default:throw new Error(`Material type ${e} not supported`)}}material;hit(t,s,e,i){(!t||!t.origin)&&console.log(t);const n=this.center.subtract(t.origin),o=t.direction.lengthSquared(),l=t.direction.dot(n),h=n.lengthSquared()-this.radius*this.radius,c=l*l-o*h;if(c<0)return!1;const d=Math.sqrt(c);let u=(l-d)/o;if((u<=s||u>=e)&&(u=(l+d)/o,u<=s||u>=e))return!1;i.t=u,i.position=t.at(u);const f=i.position.subtract(this.center).scalarMultiply(1/this.radius);return i.setFaceNormal(t,f),i.material=this.material,!0}}class P{constructor(){}render(t,s,e){const i=new H([...t.map(l=>new b(l.position,l.scale,l.material,l.color)),new b(new a(0,-100.5,-1),100,w.Lambertian,new a(.7,.7,.7))]);return new T().render(i,s,e)}}onmessage=async r=>{const t=r.data,s=t.objects.map(n=>({position:q({x:n.position.x,y:n.position.y,z:n.position.z}),color:n.color,material:n.material,scale:n.scale})),i=await new P().render(s,t.options,n=>postMessage({status:"progress",data:n}));postMessage({status:"done",data:i})}})();
